E2 :: File types, Conditionals and Loops
# Files:
- examples/e2.py
----------------

Before we start creating our code, we first need to know the basic of with we are working for.

# Data Types
Python provides by default different data types that we can use.

First we have the base types that provide simple values:
- Boolean : Defined as True/False or as a result of a boolean function (e.g. comparisson)
- Integer : Natural number
- Float : Decimal number (uses dot to separate decimal part)

In addition, we have some important data types that provides us easy ways to work with text and byte information:
- String : A sequence of characters. Eg. "Hello"
- Byte : A sequence of bytes. Eg. b'Hello'

Then we have data types that provide groups of values:
- List : Mutable list of values. Eg. [1,1,2,3]
- Tuple : Inmutable list of values. Eg. (1,1,2,3)
- Set : Mutable set of values without repetition. Eg. (1,2,3)
- Dictionary : Map between key and value. Eg. {1:1, "a":2}

Finally, an useful type is Range, that provides us a way to navigate between a list values without having to number all of them.

# Working with lists
Lists are one of the more used collections in python as they provide a good number of options.

First we can create an empty list with [] or a list with any number of elements in it of any type.
For our example, let's create an empty list named "mylist".

We can use function len to see how many elements are currently on the list with len(mylist). 
We can also check if the list is empty with the not clause "not mylist", this is the equivalent of list.empty() in other languages

Now, we can add some values to it using the function append with mylist.append(value). 
These don't need to be even of the same type as we can put anything in there.


We can remove the last inserted element using the function pop "mylist.pop()", that will not only remove it from the end of the list, but return it to use. This is useful when you need the list to act like a stack of elements.

But we can also pop elements on specific points if we provide the index of them "mylist.pop(index)". Remember that indices start in 0. This is an easy way to implement a queue in python, although there are specific classes for that if we require better performance.

If we only want to query for a value in an specific position we can do that with [], like "mylist[index]".
While indices start in 0 as in most common languages, we can also use negative indices. Negative indices will start at the last element on the list from -1 being the last element on the list.

*Note:It's important to take into account that we always need to remain in the range of indices valid for our list, otherwise we will see a out of range exception.

In addition to query specific values, we can also get subranges if we provide the initial and final indice separated by ":", like "mylist[i:j]", this will return a new list with all elements from indice i until j (j not included).
Not only that, but we can leave any of the indices empty to provide the list with all elements from the first or to the last (in the same way as if we used indices 0 and -1)

Finally, we can merge 2 list simply adding them and we will get a new list containing all the elements on both.


*NOTE:
While all the actions listed here are valid for lists, it's your turn to see which ones are valid for other data types too.
